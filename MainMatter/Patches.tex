\chapter{Algoritmo de ordenamiento de parches}\label{chapter:PRA} %PRA = Patches reordering algorithm

Planteemos primeramente el esquema principal de este algoritmo. Para ellos consideremos la siguiente notaci\'on:

\begin{itemize}
	\item $\Z$: matriz que representa la imagen incompleta a recuperar, con dimensiones $N_1 \times N_2$, $N_1N_2 = N$.
	\item $\z$: versión en forma de vector(o señal) de la matriz $\Z$, con dimensiones $N \times 1$.
	\item $\P$: matriz de permutaci\'on de dimensiones $N \times N$.
\end{itemize}

Para obtener la una señal recuperada $\yhat$ a partir de $\z$ se procede de la siguiente forma:

\begin{equation}
	\begin{array}[t]{ccccccccc}
	& & \mbox{\tiny{Permutaci\'on}} & & \mbox{\tiny{Operador de suavidad}} & & \mbox{\tiny{Permutaci\'on inversa}} & &\\
	\z & \longrightarrow & \boxed{\P} & \longrightarrow & \boxed{\H} & \longrightarrow & \boxed{\P^{-1}} & \longrightarrow & \yhat \\
	\end{array}
	\label{basic:scheme}
\end{equation}

Se reordenan los elementos de $\z$ seg\'un $\P$, y a la señal resultante $\z^p$ se le aplica un operador de suavidad $\H$ con el cual se obtienen los elementos faltantes, los elementos de dicho resultado se permutan nuevamente a su pocioci\'on inicial mendiate $\P^{-1}$. Dicho vector final ser\'ia $\yhat$. Lo anterior puede expresarse como:

\begin{equation}
\yhat = \P^{-1}\H(\z^p) = \P^{-1}\H(\P\z)
\label{basic:formula}
\end{equation}

Para comprender mejor lo que se quiere lograr con este procedimiento supongamos que contamos con la imagen real, la versi\'on de $\Z$ con la informaci\'on todos sus p\'ixeles. Aunque en la pr\'actica esta imagen no existe, la utilizaremos para reflejar de forma clara el funcionamiento del esquema principal (\ref{basic:scheme}).

\begin{itemize}
	\item $\Y$: matriz de la imagen original. 
	\item $\y$: versión en forma de vector(o señal) de la matriz $\Y$.
\end{itemize}

Supongamos que la matriz de permutaci\'on $\P$ tiene la propiedad de que al ser aplicada a $\y$ se obtiene una señal suave $\y^p$. Entonces, dado que $\z^p$ y $\y^p$ solo difieren en los p\'ixeles faltantes de $\Z$, y que $\H(z^p)$ completa la señal, haciéndola suave; se puede esperar que $\yhat$ sea una aproximaci\'on de $\y$. Dicho formalmente:

\begin{equation}
	\def\arraystretch{2}
	\begin{array}{llrl}
	&                                        &     \H (\P\z ) &\approx \P\y        \\ 
	&\Longrightarrow                         & P^{-1}\H(\P\z) &\approx \P^{-1}\P\y \\
	&\overset{(\ref{basic:formula})}{\Longrightarrow} & \yhat &\approx \y          \\
	\end{array}
\end{equation}


\begin{equation}
	\z\;\left\{
	\def\arraystretch{2.2}
	\begin{array}{ccccccccc}
		\longrightarrow & \boxed{\P_1} & \longrightarrow & \boxed{\H} & \longrightarrow & \boxed{\P_1^{-1}} & \longrightarrow \\
		\longrightarrow & \boxed{\P_2} & \longrightarrow & \boxed{\H} & \longrightarrow & \boxed{\P_2^{-1}} & \longrightarrow \\
		\longrightarrow & \huge\vdots &  & \huge\vdots &  & \huge\vdots & \longrightarrow & \\
		\longrightarrow & \boxed{\P_K} & \longrightarrow & \boxed{\H} & \longrightarrow & \boxed{\P_K^{-1}} & \longrightarrow
	\end{array}
	\right\}\;\oplus\longrightarrow\boxed{\times\frac{1}{K}}\longrightarrow\yhat
\end{equation}

%	Ejemplo de algoritmo:
%	
%	\begin{algorithm}
%	    \caption{Algoritmo de Arnoldi para construir una base ortonormal del subespacio de Krylov $\mathcal{K}_\mf(\tau A,b)$}
%	    \label{alg:Arnoldi}
%	    \KwIn{Matriz $A\in \mathbb{R}^{d\times d}$, vector $b\in \mathbb{R}^{d}$ y constante $\tau$}
%	    \KwOut{Base ortonormal $\{v_1,v_2,\ldots,v_\mf,v_{\mf+1}\}$ de $K_\mf(\tau A,b)$ y matriz de Hessenberg $H_\mf=V_\mf^{\intercal}\tau A V_\mf $,
%	        donde $V_{\mf+1}=[v_1\,v_2\,\cdots \,v_\mf\,v_{\mf+1}]\in \mathbb{R}^{d\times \mf+1}$, $breakdown$ }
%	    $breakdown=false$\\
%	    $v_1=b/\lVert b \rVert_2$\\
%	    \For{ $j=1,2,\ldots,\mf$ }{
%	        $w_j=\tau A v_j$\\
%	        \For{ $i=1,\ldots,j$}{ 
%	            $\hf_{ij}=\langle w_j,v_i \rangle$\\
%	            $w_j=w_j-\hf_{ij}v_i$       
%	        }
%	        $\hf_{j+1,i}=\lVert w_j \rVert_2$\\
%	        \eIf(\tcp*[h] \emph{Break Down}\label{alg:breakdown}){$\hf_{j+1,i}<2\epsilon_{mach}$}{
%	            $\mf_{cut}=j$\\
%	             $breakdown=true$\\
%	            Stop
%	        }{
%	            $v_{j+1}=w_j/\hf_{j+1,i}$
%	        }
%	    }
%	\end{algorithm}


